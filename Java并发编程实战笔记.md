
## 线程安全性

### 修复多线程访问共享状态的错误

1. 不在线程之间共享该状态变量。   
2. 将状态修改为不可变的变量。   
3. 访问状态变量时使用同步。 

### 什么是线程安全   

无论何种情况下，多个线程访问某各类时，该类都能表现出正确的行为。   

### 无状态的对象一定是线程安全的

Servlet设计中，会经常将类设计成无状态的。这行每次请求时，只在过程中保存临时状态，并且只能该线程访问。所以每次请求之间是互不干扰，保证并发线程之间不会产生影响。

### 什么是锁的重入

当一个线程想获得一个它已经拥有锁，会成功。比如synchronized关键字，被修饰的方法可以调用其它被synchronized修饰的方法。

### 什么是竞态条件

Race condition 竞态条件简而言之就是一个线程的操作基于一个可能被其它线程改变的状态之上。具体表现有：先检查后执行，读取-修改-写入。

### 为什么不在每个方法上加上synchronized

synchronized关键字可以保证单个操作的原子性，但是不能保证在使用一个这样的类时万无一失。比如Vector类，虽然方法已经被synchronized修饰，但是组合操作仍然会出现**竞态条件（race condition）**的错误。

```java
if(!vector.contains(e)){
    vector.add(e);
}
```   

还有，synchronized加多了可能会导致活跃性和性能问题。

## 对象的共享   

### 加锁的作用

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。    

### volatile的作用    

对volatile变量的操作，编译器不会优化重排。volatile变量不会被缓存在寄存器或者对其它处理器看不见的地方，所以读取volatile变量总会返回最新写入的值。

需要注意，volatile变量的递增操作（count++），仍然不是原子性的。volatile变量只能确保可见性，而加锁机制可以保证可见性和原子性。





